# AUTOGENERATED! DO NOT EDIT! File to edit: 00_util.ipynb (unless otherwise specified).

__all__ = ['new_id', 'list_partition', 'write_file', 'read_file', 'get_notebook_name', 'run_shell', 'run', 'node',
           'spiral', 'spi', 'spir']

# Cell

import uuid

def new_id():
    return uuid.uuid4().hex

def list_partition(lines, predicate):
    l1, l2 = [], []
    for line in lines:
        (l1, l2)[not predicate(line)].append(line)
    return l1, l2

def write_file(filename, text):
    with open(filename, 'w') as f:
        return f.write(text)

def read_file(filename):
    with open(filename, 'r') as f:
        return f.read()


# Cell

from time import sleep
from IPython.display import display, Javascript
import subprocess
import os
import uuid
import re

def _get_notebook_path_and_save():
    magic = new_id()
    print(magic)
    # saves it (ctrl+S)
    display(Javascript('IPython.notebook.save_checkpoint();'))
    nb_name = None
    while nb_name is None:
        try:
            sleep(0.1)
            nb_name = subprocess.check_output(
                f'grep -l {magic} *.ipynb', shell=True).decode().strip()
        except:
            pass
    return os.path.join(os.getcwd(), nb_name)

def get_notebook_name():
    ipynb_path = _get_notebook_path_and_save()
    return re.search(r'\# default_exp (\w+) *', read_file(ipynb_path)).group(1)

_notebook_name = None


# Cell

import subprocess

def run_shell(*args, **kwargs):
    return subprocess.run(*args, shell=True, capture_output=True, **kwargs)

def run(*args, **kwargs):
    shell = run_shell(*args, **kwargs)
    err = shell.stderr.decode()
    return f'run() error: {err}' if err != '' else shell.stdout.decode()


# Cell

from IPython.core.magic import register_cell_magic

_node_cache = ''

@register_cell_magic
def node(arg, cell, test=False):
    global _node_cache
    global _notebook_name

    ipython_node_path = '_ipython_node.ts'

    def split_imports(code): return list_partition(code.splitlines(), lambda line: line.startswith('import '))
    cache_imports, cache_exports = split_imports(_node_cache)
    cell_imports, cell_exports = split_imports(cell)
    cell_exports = '\n'.join(cell_exports).strip('\n').split('\n')

    if arg == 'run':
        ts_imports = cache_imports
        ipython_imports = cache_imports + cell_imports

        ts_exports = cache_exports
        ipython_exports = cache_exports + ([] if cell_exports == [''] else (['', '// cell', 'var run = async (...args) => {'] + cell_exports + ['}', f'await run("{arg}")']))
    elif arg == 'export':
        ts_imports = cache_imports + cell_imports
        ipython_imports = ts_imports

        ts_exports = cache_exports + ([] if cell_exports == [''] else (['', '// cell'] + cell_exports))
        ipython_exports = ts_exports

    def join_imports(imports, exports):
        return ''.join([
            '\n'.join(list(dict.fromkeys(imports))),
            '' if len(imports) == 0 or len(exports) == 0 else '\n\n\n',
            '\n'.join(exports).strip('\n') + '\n'
        ])
    new_code_ts = join_imports(ts_imports, ts_exports)
    new_code_ipython = join_imports(ipython_imports, ipython_exports)

    write_file(ipython_node_path, new_code_ipython)

    if arg == 'run':
        result = run(f'NODE_NO_WARNINGS=1 node --loader ts-node/esm --es-module-specifier-resolution=node {ipython_node_path}').splitlines()
    else:
        result = []

    _node_cache = new_code_ts

    if test:
        return result, new_code_ts, new_code_ipython
    else:
        if _notebook_name is None:
            _notebook_name = get_notebook_name()

        ts_node_path = f'{_notebook_name}.ts'

        write_file(ts_node_path, new_code_ts)
        return result if result != [] else ts_node_path


# Cell

from IPython.core.magic import register_cell_magic

def _get_spiral_cache_empty(): return {'spi': '', 'spir': '', '': ''}
_spiral_cache = _get_spiral_cache_empty()

@register_cell_magic
def spiral(arg, cell, test=False):
    global _spiral_cache
    global _notebook_name

    def split_imports(code): return list_partition(code.splitlines(), lambda line: line.startswith('open '))
    cache_imports, cache_exports = split_imports(_spiral_cache[arg])
    cell_imports, cell_exports = split_imports(cell)
    cell_exports = '\n'.join(cell_exports).strip('\n').split('\n')
    spi_imports = cache_imports + cell_imports
    spi_exports = cache_exports + ([] if cell_exports == [''] else (['', '// cell'] + cell_exports))

    def join_imports(imports, exports):
        return ''.join([
            '\n'.join(list(dict.fromkeys(imports))),
            '' if len(imports) == 0 or len(exports) == 0 else '\n\n\n',
            '\n'.join(exports).strip('\n') + '\n'
        ])
    new_code_spi = join_imports(spi_imports, spi_exports)

    if arg in ['spi', 'spir']:
        if _notebook_name is None:
            _notebook_name = get_notebook_name()
        spi_path = f'{_notebook_name}.{arg}'
    else:
        spi_path = f'main.spi'

    _spiral_cache[arg] = new_code_spi

    if test:
        return new_code_spi
    else:
        write_file(spi_path, new_code_spi)
        return spi_path

@register_cell_magic
def spi(arg, cell, test=False):
    return spiral('spi', cell, test)

@register_cell_magic
def spir(arg, cell, test=False):
    return spiral('spir', cell, test)
