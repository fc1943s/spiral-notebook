open real_util


inl union_list_get forall union_type union_key_type value_type.
    (union_key : union_key_type)
    (union_list : list union_type)
    : option value_type
    =
    inl record_typecheck_value : option value_type = None
    real
        union_record_check
            `union_type
            `(`({$union_key=record_typecheck_value}))
            {check_length=false; check_type=CheckOption}

    inl some (x : value_type) : option value_type = Some x

    listm.foldBack (fun union_item acc =>
        match acc with
        | None =>
            real
                open real_core
                unbox
                    union_item
                    fun (union_item_key, union_item_value) =>
                        typecase `union_item_key * `union_key with
                        | ~x * ~x => some union_item_value
                        | _ => acc
        | _ => acc
    ) union_list None

let rec pad (count : i32) (n : string) : string =
    inl n_length : i32 = $"String.length !n"
    if n_length < count then pad count ($"$\"0{!n}\"" : string) else n

inl empty_list forall a. () : list a = Nil

inl (/@) a b = b |> listm.append a
inl (/??) a b = a |> optionm.defaultWith b
inl (/.) props key = union_list_get key props
